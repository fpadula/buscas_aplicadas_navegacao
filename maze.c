#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MINDISTANCE 15
#define TIME_BEFORE_TURN 2400
#define TARGETCOLOR 8
#define TARGETCOLOR_SILVER 30
#define CORRECTION_FACTOR 1
#define MAX_TIME_OUTSIDE_TAPE 2000
#define TOLERANCE 8
#define TRY_TO_TURN_LEFT_DEFAULT false
// Cell size: 30. Angular distance: 30*20,... = 627
#define CELL_SIZE 627

int color =0;
int error;
int time_outside_tape;

void move_cell()
{

	int FORWARDSPEED = 20;
	int adjustment;
	int traveled_distance;
	int time_multiplier = 1;
	bool try_to_turn_left = TRY_TO_TURN_LEFT_DEFAULT;

	resetMotorEncoder(motorC);
	resetMotorEncoder(motorB);

	do                                      //Percorre linha
	{
		error = SensorValue[colorSensor] - TARGETCOLOR;
		adjustment = round(error * CORRECTION_FACTOR);

		if(error > TOLERANCE){
			time_outside_tape = time1[T1];
		}

		if(time_outside_tape > MAX_TIME_OUTSIDE_TAPE * time_multiplier){
			clearTimer(T1);
			time_outside_tape = 0;
			time_multiplier = time_multiplier + 1;
			try_to_turn_left = !try_to_turn_left;
		}

		if(error < TOLERANCE){
			clearTimer(T1);
			time_outside_tape = 0;
			time_multiplier = 1;
			try_to_turn_left = TRY_TO_TURN_LEFT_DEFAULT;
		}

		if(!try_to_turn_left){
			//motor[leftMotor] = FORWARDSPEED + adjustment*.45;
			motor[leftMotor] = FORWARDSPEED*0.5 + adjustment;
			motor[rightMotor] = FORWARDSPEED*1.5 - adjustment;
			}else{
			motor[leftMotor] = FORWARDSPEED*1.5 - adjustment;
			motor[rightMotor] = FORWARDSPEED*0.5 + adjustment;
		}

		color = SensorValue[colorSensor];
		wait1Msec(50);
		traveled_distance = (getMotorEncoder(motorB)+getMotorEncoder(motorC))/2;
	}while(traveled_distance <= CELL_SIZE);
}

task main()
{
	move_cell();
	return;
}
