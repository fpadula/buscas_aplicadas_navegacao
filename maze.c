#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/**************************** LIST FUNCTIONS ******************************************************/
#define LIST_SIZE 50
#define QEUE '0'
#define STACK '1'

typedef struct{
	int x;
	int y;
} list_n;

typedef struct{
	char type;
	list_n list_nodes[LIST_SIZE];
	int last_node_pos;
} list;


void initialize_list(list *list, char type){
	int i;

	for(i=0;i<LIST_SIZE;i++){
		list->list_nodes[i].x = -1;
		list->list_nodes[i].y = -1;
	}
	list->last_node_pos = -1;
	list->type = type;
}

int pop(list *list, list_n *node){
	int i;

	if(list->type == STACK){
		if(list->last_node_pos > -1){
			node->x = list->list_nodes[list->last_node_pos].x;
			node->y = list->list_nodes[list->last_node_pos].y;
			list->list_nodes[list->last_node_pos].x = -1;
			list->list_nodes[list->last_node_pos].y = -1;
			list->last_node_pos--;
			return 1;
		}else{
			return 0;
		}
	}else if(list->type == QEUE){
		if(list->last_node_pos > -1){
			node->x = list->list_nodes[0].x;
			node->y = list->list_nodes[0].y;
			for (i=0;i<=list->last_node_pos-1;i++){
				list->list_nodes[i].x = list->list_nodes[i+1].x;
				list->list_nodes[i].y = list->list_nodes[i+1].y;
			}
			list->list_nodes[list->last_node_pos].x = -1;
			list->list_nodes[list->last_node_pos].y = -1;
			list->last_node_pos--;
			return 1;
		}else{
			return 0;
		}
	}else
		return 0;
}

int push(list *list, list_n node){
	int i;

	if(list->type == STACK){
		if(list->last_node_pos < LIST_SIZE - 1){
			list->last_node_pos++;
			list->list_nodes[list->last_node_pos-1].x = node.x;
			list->list_nodes[list->last_node_pos-1].y = node.y;
			return 1;
		}else{
			return 0;
		}
	}else if(list->type == QEUE){
		if(list->last_node_pos < LIST_SIZE - 1){
			for (i=list->last_node_pos;i>0;i--){
				list->list_nodes[i].x = list->list_nodes[i-1].x;
				list->list_nodes[i].y = list->list_nodes[i-1].y;
			}
			list->last_node_pos++;
			list->list_nodes[0].x = node.x;
			list->list_nodes[0].y = node.y;
			return 1;
		}else{
			return 0;
		}
	}else
		return 0;
}


/**************************** GRID FUNCTIONS *********************************************/

#define GRID_NROWS 4
#define GRID_NCOLS 6
#define MINDISTANCE 20
#define TARGETCOLOR 8
#define TARGETCOLOR_CITY 44
#define CORRECTION_FACTOR 1
#define MAX_TIME_OUTSIDE_TAPE 2000
#define TOLERANCE 8
#define TRY_TO_TURN_LEFT_DEFAULT false
#define DIREITA 1
#define ESQUERDA 0
#define NORTE 0
#define SUL 1
#define LESTE 2
#define OESTE 3
#define TURN_TIME 120
#define CELL_SIZE 627 // Cell size: 30. Angular distance: 30*20,9 = 627

void move_straight(int ammount, int orientation, int *position)
{
	int counter = 1;
	int error;
	int FORWARDSPEED = 20;
	int adjustment;
	int traveled_distance;
	bool try_to_turn_left = TRY_TO_TURN_LEFT_DEFAULT;

	while(counter <= ammount){
		resetMotorEncoder(motorC);
		resetMotorEncoder(motorB);
		try_to_turn_left = TRY_TO_TURN_LEFT_DEFAULT;
		do
		{
			error = abs(SensorValue[colorSensor] - TARGETCOLOR);
			adjustment = round(error * CORRECTION_FACTOR);
			if(error < TOLERANCE){
				try_to_turn_left = TRY_TO_TURN_LEFT_DEFAULT;
			}

			if(!try_to_turn_left){
				motor[leftMotor] = FORWARDSPEED*1.5 - adjustment;
				motor[rightMotor] = FORWARDSPEED*0.5 + adjustment;

			}else{
				motor[leftMotor] = FORWARDSPEED*0.5 - adjustment;
				motor[rightMotor] = FORWARDSPEED*1.5 + adjustment;
			}
			wait1Msec(50);
			traveled_distance = (getMotorEncoder(motorB)+getMotorEncoder(motorC))/2;
		}while(traveled_distance <= CELL_SIZE);
			switch(orientation){
				case (NORTE):
					position[1] = position[1] + 1;
				break;

				case (SUL):
					position[1] = position[1] - 1;
				break;

				case (LESTE):
					position[0] = position[0] + 1;
				break;

				case (OESTE):
					position[0] = position[0] - 1;
				break;

				default:
				break;
			}
		counter++;
	}
}

void turn(int direction, int *orientation){
	int distance;
	int error;
	int FORWARDSPEED = 20;
	resetMotorEncoder(motorC);
	resetMotorEncoder(motorB);

	if(direction == DIREITA){
		do{
			motor[leftMotor] = FORWARDSPEED;
			motor[rightMotor] = -FORWARDSPEED;
			error = abs(SensorValue[colorSensor] - TARGETCOLOR);
			distance = getMotorEncoder(motorB);
		}while(distance < TURN_TIME || error > TOLERANCE);

		switch(*orientation){
			case (NORTE):
				*orientation = LESTE;
			break;

			case (SUL):
				*orientation = OESTE;
			break;

			case (LESTE):
				*orientation = SUL;
			break;

			case (OESTE):
				*orientation = NORTE;
			break;

			default:
			break;
		}
	}else if(direction == ESQUERDA){
		do{
			motor[leftMotor] = -FORWARDSPEED;
			motor[rightMotor] = FORWARDSPEED;
			error = abs(SensorValue[colorSensor] - TARGETCOLOR);
			distance = getMotorEncoder(motorC);
		}while(distance < TURN_TIME || error > TOLERANCE);

		switch(*orientation){
			case (NORTE):
				*orientation = OESTE;
			break;

			case (SUL):
				*orientation = LESTE;
			break;

			case (LESTE):
				*orientation = NORTE;
			break;

			case (OESTE):
				*orientation = SUL;
			break;

			default:
			break;
		}
	}
}

void print_grid(int *grid){
	int i,j;

	for(i=0;i<GRID_NROWS;i++){
		for(j=0;j<GRID_NCOLS;j++){
			writeDebugStream("%d ", grid[GRID_NCOLS*i + j]);
		}
		writeDebugStreamLine("");
	}

}

bool set_grid(int *grid, int x, int y, int value){
	if(x >=0 && y >=0 && x < GRID_NROWS && y < GRID_NROWS){
		grid[GRID_NCOLS*x + y] = value;
		return true;
	}
	return false;
}

bool update_non_visited(int *grid, int x, int y, int value){
	if(grid[GRID_NCOLS*x + y] == -1)
		return set_grid(grid,x,y,value);
	else
		return false;
}

void check_surroundings(int *grid, int *position, int orientation, list *nodes_to_visit){
	bool obstacle[3];
	list_n new_node;

	turn(DIREITA, &orientation);
	if(SensorValue[sonarSensor] <= MINDISTANCE)
		obstacle[0] = true;
	else
		obstacle[0] = false;

	turn(ESQUERDA, &orientation);
	if(SensorValue[sonarSensor] <= MINDISTANCE)
		obstacle[1] = true;
	else
		obstacle[1] = false;

	turn(ESQUERDA, &orientation);
	if(SensorValue[sonarSensor] <= MINDISTANCE)
		obstacle[2] = true;
	else
		obstacle[2] = false;

	turn(DIREITA, &orientation);

	switch(orientation){
		case (NORTE):
			if (update_non_visited(grid, position[0] - 1,position[1], obstacle[0] ? 2 : 0)){
				new_node.x = position[0] - 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
			if (update_non_visited(grid, position[0],position[1] + 1, obstacle[1] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] + 1;
				push(nodes_to_visit, new_node);
			}
			if (update_non_visited(grid, position[0] + 1,position[1], obstacle[2] ? 2 : 0)){
				new_node.x = position[0] + 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
		break;

		case (SUL):
			if(update_non_visited(grid, position[0] + 1,position[1], obstacle[0] ? 2 : 0)){
				new_node.x = position[0] + 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0],position[1] - 1, obstacle[1] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] - 1;
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0] - 1,position[1], obstacle[2] ? 2 : 0)){
				new_node.x = position[0] - 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
		break;

		case (LESTE):
			if(update_non_visited(grid, position[0],position[1] + 1, obstacle[0] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] + 1;
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0] + 1,position[1], obstacle[1] ? 2 : 0)){
				new_node.x = position[0] + 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0],position[1] - 1, obstacle[2] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] - 1;
				push(nodes_to_visit, new_node);
			}
		break;

		case (OESTE):
			if(update_non_visited(grid, position[0],position[1] - 1, obstacle[0] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] - 1;
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0] - 1,position[1], obstacle[1] ? 2 : 0)){
				new_node.x = position[0] - 1;
				new_node.y = position[1];
				push(nodes_to_visit, new_node);
			}
			if(update_non_visited(grid, position[0],position[1] + 1, obstacle[2] ? 2 : 0)){
				new_node.x = position[0];
				new_node.y = position[1] + 1;
				push(nodes_to_visit, new_node);
			}
		break;

		default:
		break;
	}

}

bool check_objective(){
	bool detected_collor;
	int distance;
	int error;
	int FORWARDSPEED = 20;

	resetMotorEncoder(motorC);
	resetMotorEncoder(motorB);
	detected_collor = false;
	do{
		motor[leftMotor] = FORWARDSPEED;
		motor[rightMotor] = -FORWARDSPEED;
		error = abs(SensorValue[colorSensor] - TARGETCOLOR);
		distance = getMotorEncoder(motorB);
	}while(distance < TURN_TIME);

	error = abs(SensorValue[colorSensor] - TARGETCOLOR_CITY);
	if (error < TOLERANCE)
		detected_collor = true;

	do{
		motor[leftMotor] = -FORWARDSPEED;
		motor[rightMotor] = FORWARDSPEED;
		error = abs(SensorValue[colorSensor] - TARGETCOLOR);
	}while(error > TOLERANCE);

	return detected_collor;
}

bool move_to(int *grid, int *position, int orientation, list_n dest){
	return false;
}

/**************************** MAIN ROUTINE ********************************************************/



task main()
{
	int grid[GRID_NROWS*GRID_NROWS] =  { {-1} };
	int orientation;
	int position[2];
	int cities_found;
	list nodes_to_visit;
	list_n node_to_move;


	/********Initializing structures********/
	position[0] = 0;
	position[1] = 3;
	orientation = SUL;
	cities_found = 0;
	set_grid(grid,2,3,3); // GOAL
	initialize_list(nodes_to_visit, QEUE);
	/***************************************/


	while (cities_found <= 4){
		if(check_objective()){
			cities_found++;
		}
		set_grid(grid,position[0],position[1],1);
		check_surroundings(grid, position, orientation, nodes_to_visit);
		if(pop(nodes_to_visit, node_to_move)){ // Has node to move to.
			move_to(grid,position,orientation,node_to_move);
		}
	}
	return;
}
